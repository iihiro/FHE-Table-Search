# システム概要

準同型表探索による関数計算ライブラリ(以下,本ライブラリ)は, Userの機能を提供する *Userライブラリ* , Decryptorの機能を提供する *Decryptorライブラリ* , ComputationServerの機能を提供する *ComputationServerライブラリ* から構成される. 各ライブラリはそれが示すパーティのアプリケーションを実装する際に利用されることを想定している. 以下に,各ライブラリを使用して作成されたUserアプリケーション(図中のUser), Decryptorアプリケーション(図中のDecryptor)およびComputationServerアプリケーション(図中のComputationServer)の3つのアプリケーションが互いに連携して準同型表探索による関数計算プロトコルの処理を行う例を示す.

```eval_rst
.. image:: images/fhetbl_design-flow.png
   :align: center
   :scale: 70%
```

## User

Userライブラリを使用して作成されたアプリケーションは,クライアントアプリケーションとして動作する. 以下に処理フローを示す.

* 新規の鍵ペアを生成するためのリクエストをDecryptorへ送信し,keyIDと鍵ペア(SecretKeyおよびPublicKey)を受け取る( **(1)** )
* 入力値(1つもしくは2つ)を暗号化し,keyIDと共にComputationServerへ送信する( **(4)** )
* 結果リクエストをComputationServerへ送信し,暗号化された結果を取得する( **(11)** ). ただし,ComputationServerで計算が完了していない場合はその旨の応答が返ってくる.
* 暗号化された結果をSecretKeyを用いて復号化し,計算結果を得る( **(12)** )
* **(1)** で生成した鍵ペアは,そのままDecryptor上に保持しておくこともできるが,鍵ペア破棄リクエストをkeyIDと共にDecryptorへ送信することで,keyIDに対応した鍵ペアを破棄する( **(13)** )

## Decryptor

Decryptorライブラリを使用して作成されたアプリケーションは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下にリクエストと処理の概要を示す.

* 新規の鍵ペアを生成するためのリクエスト受信時
  * 新規の鍵ペアを生成し,識別子となるkeyIDを生成した上で,鍵ペアとkeyIDをレスポンスとして返す( **(2)** )
* 公開鍵リクエスト受信時
  * keyIDに対応した公開鍵が存在すればその公開鍵を,存在しなければその旨をレスポンスとして返す( **(5)** )
* 計算リクエスト(中間結果)受信時
  * 中間結果を復号化し,PIRクエリを生成して,それをレスポンスとして返す( **(9)** )
* 鍵ペア破棄リクエストを受信時
  * keyIDに対応した鍵ペアを破棄し,処理結果をレスポンスとして返す( **(14)** )

## ComputationServer

ComputationServerライブラリを使用して作成されたアプリケーションは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下にリクエストと処理の概要を示す.

* クエリを受信時
  * クエリを識別するためのqueryIDを生成した上で,計算を非同期で開始する. その上でqueryIDをレスポンスとして返す( **(4)** )
  * 非同期で以下の処理を行う
    * 公開鍵リクエストをkeyIDと共にDecryptorへ送信し,公開鍵を受信する( **(5)** )
    * Look Up Table(以下, LUT)を生成する( **(6)** )
    * クエリの暗号化された入力値を元に,中間結果をLUTから探索した上で,それをkeyIDと共にDecryptorへ送信し,PIRクエリを受信する( **(8)** )
    * PRIクエリを元に出力値をLUTから探索する( **(10)** )
* 結果リクエスト受診時
  * queryIDに対する計算が完了していた場合は,その暗号化された結果をレスポンスとして返す. 計算が完了していない場合は,その旨をレスポンスとして返す( **(11)** )

