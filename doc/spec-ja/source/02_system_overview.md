# システム概要

準同型表探索による関数計算ライブラリ(以下,本ライブラリ)は, Userパーティの機能を
提供する *Userライブラリ* , Decryptorパーティの機能を提供する *Decryptorライブラリ* , ComputationServerパーティの機能を提供する *ComputationServerライブラリ* から構成される. 各ライブラリはそれが示すパーティのアプリケーションを実装する際に利用されることを想定している. 以下に,各ライブラリを使用して作成されたUserアプリケーション(図中のUser), Decryptorアプリケーション(図中のDecryptor)およびComputationServerアプリケーション(図中のComputationServer)の3つのアプリケーションによる処理フローを示す.

```eval_rst
.. image:: images/fhetbl_design-flow.png
   :align: center
   :scale: 70%
```

## User

Userは,クライアントアプリケーションとして動作する. 以下に処理フローを示す.

* 新規の鍵ペアを生成するためのリクエストをDecryptorへ送信し,keyIDと鍵ペア(SecretKeyおよびPublicKey)を受け取る( **(1)** )
* 入力値(1つもしくは2つ)を暗号化する( **(3)** )
* クエリ(keyID,関数番号および暗号化された入力値)をComputationServerへ送信し,queryIDを取得する( **(4)** )
* 結果リクエストをComputationServerへ送信し,queryIDに対応した結果を取得する( **(10)** ). ただし,queryIDに対応した計算が完了していない場合は,その旨の応答が返ってくる.
* 暗号化された結果をSecretKeyを用いて復号化し,計算結果を得る( **(11)** )
* **(1)** で生成した鍵ペアは,そのままDecryptor上に保持しておくこともできるが,鍵ペア破棄リクエストをDecryptorへ送信することで,keyIDに対応した鍵ペアを破棄することができる( **(13)** )

## Decryptor

Decryptorは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下に処理フローを示す.

* 新規鍵ペア生成リクエスト受信時
  * 新規の鍵ペアとそれを識別するkeyIDを生成した上で,鍵ペアとkeyIDをレスポンスとして返す( **(2)** )
* 公開鍵リクエスト受信時
  * keyIDに対応した公開鍵が存在すればその公開鍵を,存在しなければその旨をレスポンスとして返す( **(5)** )
* 計算リクエスト(中間結果)受信時
  * 中間結果を復号化し,PIRクエリを生成して,それを再度暗号化した上でレスポンスとして返す( **(8)** )
* 鍵ペア破棄リクエストを受信時
  * keyIDに対応した鍵ペアを破棄し,処理結果をレスポンスとして返す( **(13)** )

## ComputationServer

ComputationServerは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下に処理フローを示す.

* クエリ受信時
  * クエリを識別するためのqueryIDを生成した上で,queryIDをレスポンスとして返す。. 受信したkeyID, 関数番号および暗号化された入力値を用いて計算を非同期で開始する.( **(4)** )
  * 非同期で以下の処理を行う
    * 公開鍵リクエストをDecryptorへ送信し,公開鍵を受信する( **(5)** )
    * 暗号化された入力値を元に,中間結果をLUTから探索した上で,それをDecryptorへ送信し,PIRクエリを受信する( **(6)(7)** )
    * PRIクエリを元にクエリを再構築し,LUTから出力値を探索する( **(9)** )
* 結果リクエスト受診時
  * queryIDに対する計算が完了していた場合は,その出力値をレスポンスとして返す. 計算が完了していない場合は,その旨をレスポンスとして返す( **(10)** )

