# システム概要

準同型表探索による関数計算ライブラリ(以下,本ライブラリ)は, Userパーティの機能を
提供する *Userライブラリ* , Decryptorパーティの機能を提供する *Decryptorライブラリ* , ComputationServerパーティの機能を提供する *ComputationServerライブラリ* から構成される. 各ライブラリはそれが示すパーティのアプリケーションを実装する際に利用されることを想定している. 以下に,各ライブラリを使用して作成されたUserアプリケーション(図中のUser), Decryptorアプリケーション(図中のDecryptor)およびComputationServerアプリケーション(図中のComputationServer)の3つのアプリケーションによる処理フローを示す.

```eval_rst
.. image:: images/fhetbl_design-flow.png
   :align: center
   :scale: 70%
```

## User

Userは,クライアントアプリケーションとして動作する. 以下に処理フローを示す.

* 新規の鍵ペアを生成するためのリクエストをDecryptorへ送信し,keyIDと鍵ペア(SecretKeyおよびPublicKey)を受け取る( **(1)** )
* 入力値(1つもしくは2つ)を暗号化する( **(3)** )
* クエリ(keyIDと暗号化された入力値)をComputationServerへ送信し,queryIDを取得する( **(4)** )
* 結果リクエストをComputationServerへ送信し,queryIDに対応した結果を取得する( **(10)** ). ただし,queryIDに対応した計算が完了していない場合は,その旨の応答が返ってくる.
* 暗号化された結果をSecretKeyを用いて復号化し,計算結果を得る( **(11)** )
* **(1)** で生成した鍵ペアは,そのままDecryptor上に保持しておくこともできるが,鍵ペア破棄リクエストをDecryptorへ送信することで,keyIDに対応した鍵ペアを破棄することができる( **(13)** )

## Decryptor

Decryptorは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下に処理フローを示す.

* 新規鍵ペア生成リクエスト受信時
  * 新規の鍵ペアとそれを識別するkeyIDを生成した上で,鍵ペアとkeyIDをレスポンスとして返す( **(2)** )
* 公開鍵リクエスト受信時
  * keyIDに対応した公開鍵が存在すればその公開鍵を,存在しなければその旨をレスポンスとして返す( **(5)** )
* 計算リクエスト(中間結果)受信時
  * 中間結果を復号化し,PIRクエリを生成して,それを再度暗号化した上でレスポンスとして返す( **(8)** )
* 鍵ペア破棄リクエストを受信時
  * keyIDに対応した鍵ペアを破棄し,処理結果をレスポンスとして返す( **(13)** )

## ComputationServer

ComputationServerは,サーバアプリケーションとして動作する. 外部から受け取ったリクエストに対して,対応する処理を行った上でレスポンスを返す. 以下に処理フローを示す.

* クエリ受信時
  * クエリを識別するためのqueryIDを生成した上で,queryIDをレスポンスとして返す。. 受信した暗号化データを入力として計算を非同期で開始する.( **(4)** )
  * 非同期で以下の処理を行う
    * 公開鍵リクエストをDecryptorへ送信し,公開鍵を受信する( **(5)** )
    * 暗号化された入力値を元に,中間結果をLUTから探索した上で,それをDecryptorへ送信し,PIRクエリを受信する( **(6)(7)** )
    * PRIクエリを元にクエリを再構築し,LUTから出力値を探索する( **(9)** )
* 結果リクエスト受診時
  * queryIDに対する計算が完了していた場合は,その出力値をレスポンスとして返す. 計算が完了していない場合は,その旨をレスポンスとして返す( **(10)** )

